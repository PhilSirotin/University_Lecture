## Два способа передачи аргументов
В языках программирования, как приавило, предусматриваются два способа передачи аргумнетов в подпрогрыммы(функции, методы, процедуры). 
- Вызов по значению (call-by-value), при котором значение аргумента копируется в формальный параметр подпрограммы. Таким образом, изменения, внесенные в параметры подпрограммы, не влияют на аргументы, используемые при ее вызове
- Вызов по ссылке(call-by-reference). В этом случае в параметр копируется адрес аргумента( а не его значение). В пределах подпрограммы адрес используется для доступа к реальному аргументу, заданному при ее вызове. Это означает, что изменения, внесенные в параметр, окажут воздействие на аргумент, используемый для вызова подпрограммы

## Как в С++ реализована передача аргументов
По умолчанию для передачи аргументов в С++ применяется метод вызова по значению. В общем случае код функции не может изменить аргументы, используемые при вызове функции. 
```cpp
[[include]] <iostream>  
  
using namespace std;  
  
double recuprocial(double x);  
  
int main() {  
    double t = 10.0;  
    cout << "Reciprocal of 10.0 is " << recuprocial(t) << endl;  
    cout << "Value of t is still: " << t << endl;  
    return 0;  
}  
  
double recuprocial(double x) {  
    x = 1 / x;  
    return x;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
Reciprocal of 10.0 is 0.1
Value of t is still: 10

Process finished with exit code 0
```

## Использование указателя для обеспечения вызова по ссылке
Несмотря на то что в С++ в качестсве соглашения о передаче параметров по умолчанию действует вызов по значению, его можно << вручную >> заменить вызовом по ссылке. В этом случае функции будет передаваться адрес аргумента. Это позволит ее внутреннему коду изменить значение аргумента, которое хранится за ее пределами.
Рассмотрим функцию swap()
swap() - меняет значения двух переменных, на которые указывают ее аргументы)

```cpp
void change(int *x, int *y) {  
    int temp;  
    temp = *x;  
    *x = *y;  
    *y = temp;  
}  
  
int main() {  
    int i = 10;  
    int j = 20;  
  
    cout << "Initial values of x and y: " << i << " and " << j << endl;  
    swap(i, j);  
    cout << "Initial values of x and y: " << i << " and " << j << endl;  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
Initial values of x and y: 10 and 20
Initial values of x and y: 20 and 10

Process finished with exit code 0
```
В функции main() переменной i было присвоено начальное значение 10, а переменной j - 20. Затем была, вызвана swap() с адресами переменных i и j, а не их значения.

## Ссылочные параметры
Несмотря на возможность вручную организовать вызов по ссылке с помощью операций указателя, это не всегда удобно потому что:
- такой подход вынуждает нас выполнять все операции с применением указателей
- при вызове функции нужно не забыть передать ей адреса аргументов, а не их значения
В С++ можно сориентировать комплиятор на автоматические использование вызова по ссылке для одного или нескольких параметров конкретной функции. Такая возможность реализуется с помощью ссылочного параметра (reference parameter). Он позволяет автоматически передать функции адрес аргумента. При выполнение кода функции обеспечивается его атоматическое разыменование, и поэтому нет необходимости прибегать к операция, которые используются с указателями.
Ссылочный параметр объявляется с помощью символа &, который должен предшествовать имени параметра в объявлении функции. Операции, выполняемые над ссылочным параметром, влияют на аргумент, используемый при вызове функции, а не на сам параметр.
```cpp
[[include]] <iostream>
using namespace std;
void f(int &i);  
int main() {  
    int val = 1;  
    cout << "Old value: " << val << endl;  
    f(val);  
    cout << "New value: " << val << endl;  
    return 0;  
}  
void f(int &i) {  
    i = 10;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
Old value: 1
New value: 10

Process finished with exit code 0
```

После создания ссылочный параметр автоматически ссылается(т.е. не явно указывает) на аргумент, используемый при вызове функции. При вызове функции не нужно применять к аргументу &. Помимо этого, в теле функции ссылочный параметр применяется непосредственно, т.е. без операции *. Все операции, включающие ссылочный параметр, автоматически выполняются на аргументом, который используется при вызове функции. Наконец, присваивая некоторое значение параметру-ссылке, на самом деле вы присваиваете его переменной, на которую ссылка указывает.Поэтому, применяя ссылку в качестве параметра функции, при вызове функции вы в действительности используется переменную.

## Возврат ссылок
Функция может возвращать ссылку. 
Если функция возвращает ссылку, это означает, что она возвращает неявный указатель на значение, которое она передает инструкции return. Это открывает удивительную возможность: оказывается, функцию можно использовать в левой части инструкции присваивания.

```cpp
[[include]] <iostream>
using namespace std;
double &f();  // возврат ссылки. Эта функция возвращает ссылку на значение double
  
double val = 100.0;  
  
int main() {  
    double x;  
    cout << f() << endl;   // отображаем значение val
    x = f();  // присваиваем значение val переменной х
    cout << x << endl;   // отображаем значение переменной х
    f() = 99.1;  // изменяем значение глобальной переменной val 
    cout << f() << endl;   // отображаем новое значение val 
    return 0;  
}  
  // Эта функция возвращает ссылку на значение типа double
double &f() {  
    return val;  // Возвращаем ссылку на переменную val 
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
100
100
99.1
```

Вот еще пример:
```cpp
[[include]] <iostream>
using namespace std;

double &change_it(int i);  
double vals[] = {1.1, 2.2, 3.3, 4.4, 5.5};  
  
int main() {  
    int i;  
    cout << "Here is original array: " << endl;  
    for (i = 0; i < 5; i++) {  
        cout << vals[i] << endl;  
    }  
    cout << endl;  
    cout << "Here is new array: " << endl;  
    change_it(1) = 55.34;  
    change_it(2) = 55.36;  
    for (i = 0; i < 5; i++) {  
        cout << vals[i] << endl;  
    }  
    return 0;  
}  
double &change_it(int i) {  
    return vals[i];  
}
```
Это программа изменяет значение второго и третьего элемента массива.
Функция change_it объявлена как возвращающая ссылку на значение типа double. Она возвращает ссылку на элемент массива vals, который задан ей в качестве параметра i. Ссылка, возвращаемая функцией chane_it(), затем используется в main() для присвоения значение этому элементу.
При возвращении ссылки позаботьтесь о том, чтобы объект, на который она ссылается, не выходил за предела дуйствующей области видимости. Рассмотрим такую функцию.

```cpp
int &f()
{
int i = 10;
return i; // Здесь ошибка. При завершении функции f() локальная переменная i выйдет за пределы области видимости
}
```

## Независимые ссылки
Ссылки включены в С++ главным образом для поддержки способа передачи парамтеров по ссылке и для использования в качестве ссылочного типа значения, которое возвращает функция. Несмотря на это, можно объявить независимую переменную ссылочного типа - независимую ссылку. 
Независимая ссылка должна указывать на объект. Следовательно, она должна быть инициализированая при ее объявлении. Ей будет присвоен адрес некоторой ранее объявленой переменной

```cpp
[[include]] <iostream>
using namespace std;

int main() {  
    int j;  
    int k;  
    int &i = j;   // независимая ссылка
    j = 10;  
    cout << j << " | " << i << endl;  
  
    k = 121;  
    i = k;  
    cout << i << endl;  
  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
10 | 10
121

Process finished with exit code 0
```
Адрес, который содержит ссылочная переменная, фиксирован и его нельзя изменить. Таким образом, при выполнении инструкции:
```cpp
i = k
```
в переменную j (адресуемую ссылкой i) копируется значение переменной k, а нее адрес.

## Ограничение при использовании ссылок
На применение ссылочных переменных налагается ряд ограничений:
- Нельзя ссылаться на ссылочную переменную
- Нельзя создавать массивы ссылок
- Нельзя создавать указатель на ссылку, то есть нельзя применять к ней оператор &

## Перегрузка функций
В С++  несколько функций могут иметь одинаковые имена, но при условии, что их параметры различаются. Такую ситуацию называют перегрузкой функций(function overloading), а функции, которые в ней задействованы  - перегруженными (overloaded). Перегрузка функций - один из способов реализации полиморфизма в С++.
Чтобы перегрузить функцию, достаточно объявить различные ее версии. Об остальном позаботиться компилятор.
Важно:
- тип и/или количество параметров каждой перегруженной функции должны быть уникальными.
```cpp
[[include]] <iostream>
using namespace std;
void f(int i);  
void f( int i, int j);  
void f(double i);  
int main() {  
    f(10);  
    f(10,20);  
    f(12.2);  
    return 0;  
}  
void f(int i) {  
    cout << "First " << i << endl;  
}  
void f( int i, int j) {  
    cout << "Second " << i << " and " << j <<  endl;  
}  
void f( double i) {  
    cout << "Third " << i << endl;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
First 10
Second 10 and 20
Third 12.2

Process finished with exit code 0
```
Если перегрузок небыло и нам понадобились допустим функции отрицания для данных типа int, double, long, нам бы понадобилось создать 3 разные функции(например: ineg, dneg,lneg);
Но благодаря перегрузке можно обойтись только одним именем.
Таким образом перегрузка функций поддерживает принцип полиморфизма "Один интерфейс - множество методов"
```cpp
[[include]] <iostream>
using namespace std;
int neg(int n);  
double neg(double n);  
long neg(long n);  
int main() {  
    cout << "neg(-10): " << neg(-10) << endl;  
    cout << "neg(9L): " << (neg(9L)) << endl;  
    cout << "neg(3.14): " << neg(3.14) <<  endl;  
    return 0;  
}  
int neg(int n) {  
    return -n;  
}  
double neg(double n) {  
    return -n;  
}  
long neg(long n) {  
    return -n;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
neg(-10): 10
neg(9L): -9
neg(3.14): -3.14

Process finished with exit code 0
```
Ценность перегзки состоим в том, что с ее помощью можно обращаться к связнным функциям посредство одного, общего для всех, имени. Благодаря, полиморфизму  вам нужно помнить не три различных имени, а только одно.
Еще одно достоинтсво перегрузки заключается в том, что она позволяет определить версии одной функции с небольшими различиями, которые зависят от типа обрабатываемых этой функцией данных.
```cpp
[[include]] <iostream>
using namespace std;
int min(int a, int b);  
char min(char a, char b);  
int* min(int* a, int* b);  
  
int main() {  
    int i = 10;  
    int j = 20;  
    cout << "min('c', 'b')" <<  min('c', 'b') << endl;  
    cout << "min(9,3)" <<  min(9,3) << endl;  
    cout << "*min(&i, &j: " << *min(&i, &j) << endl;  
    return 0;  
}  
int min(int a, int b) {  
    if (a < b) {  
        return a;  
    } else {  
        return b;  
    }  
}  
char min(char a, char b) {  
    if (tolower(a) < tolower(b)) {  
        return a;  
    } else {  
        return b;  
    }  
}  
int* min(int* a, int* b) {  
    if (*a < *b) {  
        return a;  
    } else {  
        return b;  
    }  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
min('c', 'b')b
min(9,3)3
*min(&i, &j: 10

Process finished with exit code 0
```
## Автоматическое преобразование типов и перегрузка
Автоматическое преобразование типов применимо и к параметрам перегруженных функций.
```cpp
[[include]] <iostream>
using namespace std;
void f(int x);  
void f(double x);  
int main() {  
    int i = 10;  
    double d = 10.1;  
    short s = 99;  
    float r = 11.5f;  
    f(i);  
    f(d);  
    f(s);  
    f(r);  
}  
void f(int x) {  
    cout << "inside f(int)" << x << endl;  
}  
void f(double x) {  
        cout << "inside f(double)" << x << endl;  
}  
void f(short x) {  
    cout << "inside f(short)" << x << endl;  
}
```

## Создание перегруженных функций вывода
println() - выводит после заданного аргумента символ новой строки.
print() - только аргумент
```cpp
[[include]] <iostream>
using namespace std;
void println(bool b);  
void println(int i);  
void println(long i);  
void println(char ch);  
void println(const char *str);  
void println(double d);  
  
void print(bool b);  
void print(int i);  
void print(long i);  
void print(char ch);  
void print(const char *str);  
void print(double d);  
  
void println(bool b) {  
    if (b) {  
        cout << "True\n";  
  
    }else {  
        cout << "False\n";  
    }  
}  
void println(int i) {  
    cout << i << "\n";  
}  
void println(long i) {  
    cout << i << "\n";  
}  
void println(char ch) {  
    cout << ch << "\n";  
}  
void println(const char *str) {  
    cout << str << "\n";  
}  
void println(double d) {  
    cout << d << "\n";  
}  
void print(bool b) {  
    if (b) {  
        cout << "True";  
    } else {  
        cout << "False";  
    }  
}  
void print(int i) {  
    cout << i;  
}  
void print(long i) {  
    cout << i;  
}  
void print(char ch) {  
    cout << ch;  
}  
void print(const char *str) {  
    cout << str;  
}  
void print(double d) {  
    cout << d;  
}  
int main() {  
    println(true);  
    println(10);  
    println("This is a test");  
    println('x');  
    println(99L);  
    println(123.23);  
  
    print("Here are some values: ");  
    print(false);  
    print(' ');  
    print(88);  
    print(' ');  
    print(1000L);  
    print(' ');  
    print(100.01);  
    println(" Done! ");  
    return 0;  
}
```

## Аргументы, передаваемые по умолчанию
В С++ можно придать параметру значение, которое применяется автоматически, если при вызове функции не задается аргумент, соответсвующий этому параметру. 
Аргументы функции, передаваемые по умолчанию, задаются синтаксически аналогично инициализации переменных. 

```cpp
void myfunc(int x = 0, int y = 100);
// После такого объявляения функцию myfunc() можно вызвать одним из трех способов:
myfunc(1, 2); // Передаем явно заданные значения
myfunc(10); // Передаем для параметра х значение 10б а для параметра у позволяем применить значение, задаваемое по умолчанию (100) 
myfunc(); // Для х и у оставляем значение по умолчанию
```

```cpp
[[include]] <iostream>
using namespace std;
void myfunc(int x = 0, int y = 100) {  
    cout << "x: " << x << " y: " << y << endl;  
}  
int main() {  
    myfunc(1,2);  
    myfunc(20);  
    myfunc();  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
x: 1 y: 2
x: 20 y: 100
x: 0 y: 100

Process finished with exit code 0
```
При создании функций со значениями аргументов, передаваемых по умолчанию, следует помнить, что эти значения должны быть заданы только один раз и при первом объявлении функции в файле.
Хотя передаваемые по умолчанию аргументы определяются лишь однажды, для каждой версии перегруженной функции для передачи по умолчанию можно задавать разные аргументы.

Все параметры, принимающие значения по умолчанию, должны располагаться справа от остальных.
```cpp
//Неверно
void f(int a = 1; int b);
```
Если вы начали определять параметры со значениями по умолчанию, вы уже не можете указывать параметры без дефолтного значения.
```cpp
// Неверно, поскольку для значения i определено значение по умолчанию, для параметра j нужно задать значение аналогичным способом
void myfunc(float f, char *str, int i = 10; int j);
```

### Аргументы по умолчанию и перегрузка фукнций
Одним из вариантов применения аргументов по умолчанию является сокращенная форма перегрузки функции.
```cpp
[[include]] <iostream>
using namespace std;
void mystrcat(char* s1, char* s2, int len = 10) {  
    while (*s1) {  
        s1++;  
    }  
    if (len == 0) {  
        len = strlen(s2);  
    }  
    while (*s2 && len) {  
        *s1 = *s2;  
        s1++;  
        s2++;  
        len--;  
    }  
    *s1 = '\0';  
}  
  
int main() {  
    char str1[80] = "This is a test";  
    char str2[80] = "0123456789";  
  
    mystrcat(str1, str2, 5);  
    cout << str1 << endl;  
  
    strcpy(str1, "This is a test");  
    mystrcat(str1, str2);  
    cout << str1 << endl;  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 6/Test/cmake-build-debug/Test"
This is a test01234
This is a test0123456789

Process finished with exit code 0
```
Здесь mystrcat() присоеденяет len символов строки, адресумой параметром s2, к концу строки, адресуемой параметром s1. Но если значение len равно нулю, как и в случае разрешения передачи этого аргумента по умолчанию, mystrcat() присоеденит к строке s1 всю строку, адресуемую параметром s2(Иными словами, если значение len равно нулю, 0, функция mystrcat() действует подобно стандартной функции strcat().) Используя для параметра len возможность передавать аргументы по умолчанию, обе операции можно объеденить в одной функции.

## Перегрузка функций и неодназначность
Иногда компилятор, не способен сделать выбор между двумя(или более) корректно перегруженными функциями. Такие ситуации и называют неодназначными.
Инструкции, создающие неодназначность, являются ошибочными, а программы, которые их содержат, скомпилированы не будут.
Основной причиной неоднозначности в С++ является автоматическое преобразование типов.
```cpp
int myfunc(double d);
// ...
cout << myfunc('c'); // Ошибки нет, выполняет преобразование типов
```
Ошибки здесь нет, поскольку в С++ автоматически преобразует символ с в его эквивалент в типа double.

```cpp
[[include]] <iostream>
using namespace std;
float myfunc(float i) {  
    return i;  
}  
double myfunc(double i) {  
    return -i;  
}  
int main() {  
// Неодназначности нет, т.к. вызывается функция myfunc(double i)
    cout << myfunc(1.5) << endl;
    // Присутствует неодназначность, т.к неизвестно какую функцию myfunc(), следует вызывать  
    cout << myfunc(10) << endl;  
    return 0;  
}
```

Неодназначность может быть также вызвана использованием в перегруженных функциях аргументов, передаваемых по умолчанию.

```cpp
[[include]] <iostream>
using namespace std;
int myfunc(int i) {  
    return i;  
}  
int myfunc(int i, int j = 1) {  
    return i * j;  
}  
int main() {  
    myfunc(4,5); // Неодназначности нет  
    myfunc(10); // Неодназначность, ошибка! Неясно, то ли считать параметр j задаваемым по умолчанию, то ли вызывать версию функции myfunc() с одним параметрмо?  
    return 0;  
}
```


## Функция modf()
modf() - разделяет число на целую и дробную части. 