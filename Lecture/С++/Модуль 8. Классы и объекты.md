
## Определение класса
Класс можно представить как некий шаблон, который определяет формат объекта. Он включает как данные, так и код.
В Языке С++ спецификация класса используется для построения объектов.
Объекты - экземпляр класса
Класс представляет собой набор планов, которые определяют, как строить объект. 
Важно понимать:
	Класс - логическая абстракция, которая реально не существует до тех пор, пока не будет создан объект этого класса
Определяя класс, мы объявляем данные, которые он содержит, и выполняемый над ними код.
Данные в классе объявляются в виде переменных, а код оформляется в виде функций.
Члены класса - функции и переменные данные в классе
Член данных - переменная объявленная в классе
Функция-члена - функция объявленная в классе

## Синтаксис объявления класса
Класс создается с помощью ключевого слова class.
Синтаксис:
```cpp
class имя_класса {
		приватные данные и функции
public:
публичные данные и функции
} список_объектов
```
Имя класса - имя нового типа, можно использовать для создания объектов класса. Для этого имена объектов указываются непосредственно за закрывающейся фигурной скобкой объявления класса, но необязательно

Класс может содержать как приватные так и публичные члены. По умолчанию все элементы, определенные в классе, приватны.
К приватным членам могут получить доступ только другие члены их класса, другие части программы этого сделать не могут.

Публичные - доступны для других часте программы, чтобы сделать части класса публичными, надо объявить их после ключевого слова public.
Как правило, в программе организуется доступ к приватным членам класса, через его публичные функции.

## Определение класса и создание объектов

Ниже представлена первая версия класса Vehicle. В нем определены три переменные экземпляра: passangers, fuelcap и mpg

```cpp.h
class Vehicle {  
public:  
    int passangers; //  количество пассажиров  
    int fuelcap; // вместимость топливных резервуаров в галлонах  
    int mpg; // расход горючего в милях  
};
```
Переменные экземпляра, определенные в классе Vehicle, иллюстрируют синтаксис их объявления.
```cpp
тип имя_переменной;
```
Здесь тип определяет тип переменной экземпляра, а имя_переменной - ее имя

Определение class создает новый тип данных.

Чтобы создать объект класса Vehicle, можем использовать такую инструкцию
```cpp
Vehicle minivan; // Создаем объект minivan типа Building
```
После ее выполнения объект minivan станет экземпляром класса Vehicle, то есть обретет физическую форму.

Всякий раз при создании экземпляра класса создается объект, который содержит собственную копию каждой переменной экземпляра, определенной этим классом. Таким образом, каждый объект класса Vehicle будет содержать собственные копии переменных экземпляра passengers, fuelcap и mpg.

Для доступа к этим переменным используется операция .(точка).
Синтаксис:
```cpp
объект.член
```
Чтобы к примеру, присвоить переменной fuelcap объекта minivan значение 16 надо:
```cpp
minivan.fuelcap = 16;
```


```cpp
//Vehicle.h
#ifndef VEHICLE_H  
#define VEHICLE_H  
class Vehicle {  
public:  
    int passangers; //  количество пассажиров  
    int fuelcap; // вместимость топливных резервуаров в галлонах  
    int mpg; // расход горючего в милях  
};  
#endif //VEHICLE_H
```
```cpp
#include <iostream>
#include "Vehicle.h"

using namespace std;
int main() {  
    Vehicle minivan;    
    int range;   
    minivan.passangers = 7;  
    minivan.fuelcap = 16;  
    minivan.mpg = 21;   
  
    range = minivan.fuelcap * minivan.mpg;   
  
    cout << "Minivan can carry " << minivan.passangers << " with a range of " << range << endl;  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 8/Lesson_8/main.cpp/cmake-build-debug/main"
Minivan can carry 7 with a range of 336
```

Каждый  объект класса имеет собственные копии переменных экземпляра, определенные в этом классе. Следовательно, содержимое переменных в одном объекте  может отличаться от содержимого аналогичных переменных в другом.

```cpp
//Vehicle.h
#ifndef VEHICLE_H  
#define VEHICLE_H  
class Vehicle {  
public:  
    int passangers; //  количество пассажиров  
    int fuelcap; // вместимость топливных резервуаров в галлонах  
    int mpg; // расход горючего в милях  
};  
#endif //VEHICLE_H
```
```cpp
#include <iostream>
#include "Vehicle.h"

using namespace std;
int main() {  
    Vehicle minivan;  
    Vehicle sportscar;  
    int range;  
    int range2;  
    minivan.passangers = 7;  
    minivan.fuelcap = 16;  
    minivan.mpg = 21;  
  
    sportscar.passangers = 2;  
    sportscar.fuelcap = 14;  
    sportscar.mpg = 12;  
  
    range = minivan.fuelcap * minivan.mpg;  
    range2 = sportscar.fuelcap * sportscar.mpg;  
  
    cout << "Minivan can carry " << minivan.passangers << " with a range of " << range << endl;  
    cout << "Sportscar can carry " << sportscar.passangers << " with a range of " << range2;  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 8/Lesson_8/main.cpp/cmake-build-debug/main"
Minivan can carry 7 with a range of 336
Sportscar can carry 2 with a range of 168
Process finished with exit code 0
```

## Добавление в класс функций-членов
Как правило, функции-члены класса обрабатывают данные , определенные в нем, и часто обеспечивают доступ к этим данным. Другие части программы обычно взаимодействуют с классом через его функции.

Чтобы добавить функцию в класс Vehicle, нужно задать ее прототип внутри объявления этого класса.

Добавим в класс Vehicle функцию range().

```cpp
#ifndef VEHICLE_H  
#define VEHICLE_H  
class Vehicle  {  
public:  
    int passangers; //  количество пассажиров  
    int fuelcap; // вместимость топливных резервуаров в галлонах  
    int mpg; // расход горючего в милях  
  
    int range(); // Функция вычисления максимального пробега  
};   
#endif //VEHICLE_H
```

Чтобы реализовать функцию, которая является членом класса, надо сообщить компилятору, какому классу она принадлежит, квалифицировав ей имя этой функции с именем класса:
```cpp
// Реализация функции-члена range()
int Vehicle :: range(){
return mpg * fuelcap;
}
```
```cpp
#ifndef VEHICLE_H  
#define VEHICLE_H  
class Vehicle  {  
public:  
    int passangers; //  количество пассажиров  
    int fuelcap; // вместимость топливных резервуаров в галлонах  
    int mpg; // расход горючего в милях  
  
    int range(); // Функция вычисления максимального пробега  
};  
  
int Vehicle::range() {  
    return mpg * fuelcap;  
}  
#endif //VEHICLE_H
```
Операция :: - операция разрешения области видимости(операция разрешения контекста), она связывает имя класса с именем его члена, чтобы сообщить компилятору, какому классу принадлежит данная функция. Это очень важно, т.к. разные классы могут использовать одинаковые имена функций.

Функции-члены можно вызывать только относительно заданного объекта, есть два способа:
- Функция-члена может вызвать код, расположенный вне класса. В этом случае необходимо использовать имя объекта и операцию .(точка)
- Можно вызвать из другого функции-члена того же класса.


## Конструкторы и деконструкторы
Конструктор инициализирует объект при его создании. Он имеет такое же имя, что и сам класс, и синтаксически подобен функции. Однако в определении конструкторов не указывается тип возвращаемого значения.
Синтаксис:
```cpp
имя_класса(){
 // код конструктора
}
```
Обычно конструктор применяется, чтобы придать переменным экземпляра, определенным в классе, начальные значения или выполнить исходные действия, которые требуются для создания полностью сформированного объекта.

Дополнением к конструктору служит деструктор. Во многих случаях при уничтожении объекту нужно выполнить некоторое действие или даже последовательность действий.
Пример использования:
объект должен освободить ранее выделенную для него память или закрыть открытый для него файл.
Имя деструктора совпадает с именем конструктора, но предворяется символом ~. Деструкторы не возвращают значения.

```cpp
#include <iostream>  
using namespace std;  
  
class MyClass {  
    public:  
        int x;  
    MyClass();  
    ~MyClass();  
};  
  
MyClass::MyClass() {  
    x = 10;  
}  
  
MyClass::~MyClass() {  
    cout << "MyClass destructor called" << endl;  
}  
  
int main() {  
    MyClass ob1;  
    MyClass ob2;  
  
    cout << ob1.x << " " << ob2.x << endl;  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 8/Lesson_8/Test/cmake-build-debug/Vehicle.h"
10 10
MyClass destructor called
MyClass destructor called

Process finished with exit code 0
```
Обратим внимание, на публичное объявление конструктора, которое позволяет вызывать его из кода, определенного вне класса MyClass.  Этот конструктор присваивает переменной х значение 10 и вызывается при создании объекта класса MyClass
```cpp
MyClass ob1
```

## Параметризированные конструкторы
Параметры вносятся в конструктор точно так же, как в функцию: для этого достаточно объявить их внутри круглых скобок после его имени
```cpp
MyClass :: MyClass(int i){
x = i
}
```
Чтобы передать аргумент конструктору, необходимо связать передаваемое значение с объектом во время его объявления.
Есть 2 способа:
```cpp
MyClass ob1 = MyClass(101);
```
В этом объявлении создается объект класса MyClass(с именем ob1), которому передается значение 101. Эта формула используется редко.
Проще:
```cpp
MyClass ob1(101);
```
Приведем синтаксис передачи аргументов конструкторам
```cpp
тип_класса имя_переменной(список_аргументов);
```
список аргументов - представляет собой список разделенных запятыми аргументов, которые передаются конструктору.

Пример:

```cpp MyClass.h
// код файла MyClass.h
class MyClass {
public:
    int x;
    MyClass(int i);
    ~MyClass();
};
```
```cpp
//Код файла MyClass.cpp
#include "MyClass.h"  
#include <iostream>  
  
MyClass::MyClass(int i) {  
    x = i;  
}  
  
MyClass::~MyClass() {  
    std::cout << "Destructing object whose x value is " << x << std::endl;  
}
```
```cpp
// Код файла main.cpp
#include <iostream>  
#include "MyClass.h"  
  
using namespace std;  
  
int main() {  
    MyClass obj1(101);  
    MyClass obj2(102);  
  
    cout << obj1.x << endl;  
    cout << obj2.x << endl;  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 8/Test_Lab/Main/cmake-build-debug/Main"
101
102
Destructing object whose x value is 102
Destructing object whose x value is 101

Process finished with exit code 0
```

### Альтернативный вариант инициализации объекта
Если конструктор принимает толко один параметр, используется альтернативный спосбо инициализации членов объекта

```cpp
#include <iostream>
using namespace std;

class MyClass {
public: 
int x;
MyCladd(int i);
~MyClass();
};

MyClass :: MyClass(int i){
x = i;
}

MyClass :: ~MyClass(){
cout << "Destructing object whose x value is " << x << endl;
}

int main(){
MyClass ob = 5; // Вызов MyClass(5)
cout << ob.x << endl;
return 0;
}
```

В этой форме инициализация объекта число 5 автоматически передается параметру i при вызове конструктора MyClass(). Другими словами, эта инструкция объявления обрабатывается компилятором так, как если бы она была записана следующим образом:
```cpp
MyClass ob (5);
```
В общем случае, если у нас есть конструктор, который принимает только один аргумент, для инициализации объекта можно использовать либо ob(x), либо ob = x.

## Встраиваемые функции
Встраиваемая или подставляемая, функция - функция, код которой подставляется в то место строки программы, из которого она вызывается, то есть вызов такой функции заменяется ее кодом. 
Существует 2 способа создания такой функции.

1. Состоит в использовании модификатора inline. Например, чтобы создать встраиваемую функцию f(), которая возвращает значение типа int  и не принимает ни одного параметра, достаточно объявить ее следующим образом:
```cpp
inline int f()
{
// ...
}
```
Причина существования встраиваемых функций - эффективность
Если встраиваемая функция оказывается объемной, размер программы может существенно увеличиться. Поэтому лучше всего в таком качестве использзовать только маленькие функции, а те, что побольше оформлять в виде обычных

```cpp
#include <iostream>  
  
using namespace std;  
  
class cl {  
    int i;  
    public:  
    int get_i();  
    void put_i(int j);  
};  
  
inline int cl::get_i() {  
    return i;  
}  
inline void cl::put_i(int j) {  
    i = j;  
}  
int main() {  
    cl s;  
    s.put_i(10);  
    cout << s.get_i() << endl;  
    return 0;  
}
```

### Создание встраиваемых функций в объявлении класса
Существует еще один способ создания встраиваемой функции - определение кода для функции-члена класса в самом объявлении класса. Любая функция, которая определяется в объявлении класса, автоматически становится встраиваемой. В этой случае не требуется предварять ее объявление ключевым словом inline

```cpp
#include <iostream>  
  
using namespace std;  
  
class cl {  
    int i;  
public:  
    int get_i() { return i; }  
    void put_i(int j) { i = j; }  
};  
  
  
int main() {  
    cl s;  
    s.put_i(10);  
    cout << s.get_i() << endl;  
    return 0;  
}
```

Можно сформатировать и другим способом:
```cpp
#include <iostream>  
  
using namespace std;  
  
class cl {  
    int i;  
public:  
    int get_i() 
    { 
    return i;
     }  
    void put_i(int j) 
    { 
    i = j;
     }  
};  
  
  
int main() {  
    cl s;  
    s.put_i(10);  
    cout << s.get_i() << endl;  
    return 0;  
}
```

Небольшие функции обычно определяются в объявлении класса. 
Применение внутриклассовых встраиваемых публичных функций - обычная практика в программировании на С++, поскольку с их помощью обеспечивается доступ к приватным переменным. Такие функции называются получающими, или функциями доступа
