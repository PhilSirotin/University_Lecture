e## Модификаторы const и volatile
В языке С++ определено 2 модификатора типа, которые влияют на то, каким образом можно получить доступ к переменным или модифицировать их - const и volatile
### Модификатор const
Переменные, объявленные с использованием модификатора const, не могут изменить свои значения во время выполнения программы. Ей можно присвоить значение.
Чаще всего модификатор используется для создания именованных констант. Иногда в программах многократно применяется одно и то же значение для разных целей.
```cpp
[[include]] <iostream>
using namespace std;
const int enums = 100;  // Создаем именованную константу, которая содержит значение 100
int main() {  
    int arr1[enums];  
    double arr2[enums];  // Именованная константа здесь использует для задания размеров массивов
    char *arr3[enums];  
    //...
}
```
Если понадобится использовать новый размер для массивов, нам придется изменить только объявление переменной enums.

Const - также используется для защиты объекта от модификации посредством указателя. С его помощью можно предотвратить ситуацию, когда функция изменяет значение объекта, адресуемого ее параметром-указателем. Для этого достаточно объявить такой параметр-указатель с применением модификатора const.

```cpp
[[include]] <iostream>
using namespace std;
int nigate(const int *val) {  
    return -*val;  
}  
  
int main() {  
    int result;  
    int v;  
    cout << "Enter a number v: ";  
    cin >> v;  
    result = nigate(&v);  
    cout << result << endl;  
  
    return 0;  
}
```
Параметр val объявлен указателем типа const, поэтому функция negate() не может изменить значение, на которое он указывает

```cpp
// этот код работать не будет
[[include]] <iostream>
using namespace std;
int negate(cont int* val){
*val = - *val; // Ошибка: значение, адресумое параметром val, изменить нельзя
retrun val;
}
```
В этом случае программа попытается изменить значение переменной, на которую указывает val, но это не будет реализовано, поскольку val объявлен как const.

Модификатор const можно также применять для ссылочных параметров, чтобы не допустить в функции модификации переменных, на которые эти параметры ссылаются.

### Модификатор volatile
Модификатор сообщает компилятору о том, что значение соответствующей переменной можно изменить в программе неявным образом.

```cpp
volatile int current_users;
```
Теперь значение переменной current_users будет опрашиваться при каждом ее использовании.

### Модификаторы классов памяти
Язык С++ поддерживает пять модификаторов классов памяти:
- auto
- extern
- register
- static
- mutable
С помощью этих ключевых слов компилятор получает информацию о том, как нужно хранить переменную. Модификатор классов памяти требуется указывать в начале объявления переменной.

### Модификатор auto
Объявляет локальную переменную. При этом он используется довольно редко, ведь локальные переменные являются автоматическими по умолчанию.

## Модификатор extern
По мере увеличения программного файла компиляция может стать раздражающей долгой. В такой ситуации стоит разбить программу на несколько отдельных файлов. Тогда небольшие изменения, вносимые в один файл, не потребуют ее полной перекомпиляции. При разработке больших проектов многофайловый подход существенно экономит время, а реализовать его позволяет ключевое слово extern.

В программах, которые состоят из двух или более файлов, каждый файл должен знать имена и типы глобальных переменных, используемых программой в целом. Но нельзя в каждом файле объявить копии этих переменных, т.к. в С++ программа может включать только одну копию каждой глобальной переменной. Если мы объявим эти переменные в каждом файле и компановщик попытается объединить эти файлы, он обнаружит дублированные глобальные переменные и выдаст ошибку. Чтобы избежать этого, достаточно объявить все глобальные переменные в одном файле, а в остальных использовать объявления extern

| File F1                                                                                      | File F2                                                                                                             |
| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| int x,y;<br>char ch;<br><br>int main(){<br>// ...<br>}<br>void func1()<br>{<br>x = 123;<br>} | extern int x,y;<br>extern char ch;<br><br>void func22()<br>{<br>x = y/10<br>}<br>void func23()<br>{<br>y = 10;<br>} |
В файле F1 объявляются и определяются переменные x,y и ch. В файле F2 задействован скопированный из файла F1 список глобальных переменных, к объявлению которых добавлено ключевое слово extern. Модификатор extern делает переменную известной для модуля, но в реальности не создает ее. Иными словами, ключевое слово extern предоставляет компилятору информацию о типе и имени глобальных переменных, не выделяя для них памят повторно.

При объявлении переменной присваивается имя и тип, а посредством определения для нее выделяется память.

### Модификатор компоновки extern
Модификатор extern позволяет также указать, как та или иная функция связывается с программой. По умолчанию она компонуется как функция С++.  Однако с помощью спецификации компоновки(специальной инструкции для компилятора) можно обеспечить компановку функций, написанных на дргих языках программирвоания.
```cpp
extern "Language" прототип_функции
```
Здесь обозначается нужный язык.
В следующем примере myCfunc() компонуется как функция языка С:
```cpp
extern "C" void myCfunc()
```
Используя следующий формат спецификации компоновки, можно задать не одну, а сразу несколько функций
```cpp
extern "Language"{
прототипы
}
```
Для большинства задач программирвоания спецификаци компоновки вам не понадобится

## Статические переменные
Статическими называются переменные долговременного хранения, т.е. они хранят свои значения в пределах своей функции или файла. От глобальных они отличаются тем, что за рамками своей функции или файла они неизвестны. Поскольку модификатор static по-разному влияет на локальные и глобальные переменные
### Локальные статические переменные
Если к локальной переменной применен модификатор static, то для нее выделяется постоянная область памяти практически так же, как и для глобальной.
Это позволяет статической переменной поддерживать ее значение между вызовами функций(значение статистической переменной не теряется при выходе из функции).
Она известна только блоку, в котором она объявлена.

Объявляется
```cpp
static int/double etc;
```
Локальные статические переменные инициализируются только один раз, вначале выполнения программы.
```cpp
[[include]] <iostream>
using namespace std;
double running_avg(double i);  
int main() {  
    double num;  
    do {  
        cout << " Enter a number: " << endl;  
        cin >> num;  
        if (num != -1) {  
            cout << " The average is " << running_avg(num);  
        }  
    } while (num > -1);  
    return 0;  
}  
double running_avg(double i) {  
    static double sum = 0;  
    static double count = 0;  
    sum = sum + i;  
    count++;  
    return sum / count;  
}
```

### Глобальные статические переменные
Если модификатор static применяется к глобальной переменной, то компилятор создаст переменную, известную только для файла, в котором она объявлена.

Это означает, что хотя она и является глобальной, функции в других файлах не знают о ней и не могут изменить ее содержимое. Таким образом, она не подвержена внешнему воздействию.

```cpp
//main.cpp
[[include]] <iostream>  
using namespace std;  
  
int running_avg(int i);  
void reset();  
  
int main() {  
    int num;  
    do {  
        cout << "Enter a numbers(-1 to quit, -2 to reset): ";  
        cin >> num;  
        if (num == -2) {  
            reset();  
            continue;  
        }  
        if (num != -1) {  
            cout << "Running average: " << running_avg(num) << endl;  
        }  
    } while (num != -1);  
    return 0;  
}
```

```cpp
// Lesson 7.2
[[include]] <iostream>  
  
static int sum = 0;  
static int count = 0;  
  
int running_avg(int i) {  
    sum += i;  
    count++;  
    return sum / count;  
}  
  
void reset() {  
    sum = 0;  
    count = 0;  
}
```

#### Вывод 
Имя локальной статической переменной известно только функции или блоку кода, в котором она объявлена, а имя глобальной статической переменной - только файлу, в котором она расположена. По сути, модификатор static позволяет переменным существовать так, что о них знают лишь использующие их функции.

## Регистровые переменные
Не используются с С++17, т.к. компилятор теперь сам определяет
## Перечисления
В языке С++ можно определить список именованных целочисленных констант, называемый перечислением(enumeration). Эти константы можно затем использовать везде, где допустимы целочисленные значения. Перечисления определяются с помощью ключевого слова enum, а синтаксис их определения имеет следующий вид:
```cpp
enum тип {список_перечисления} список переменных;
```
Список_перечисления - список разделенных запятыми имен, которые представляют значения перечисления.
Список_переменных не является обязательным, поскольку переменные можно объявить позже, используя тип перечисления

В примере определяется перечисление transport и две переменные типа transport с именами t1,t2
```cpp
enum transport {car, truck,airplane, train, boat} t1,t2
```
Определив перечисление, вы можете объявить другие переменные этого типа, используя имя типа перечисления.

```cpp
transport how;
// объявляется одна переменная how перечисления transport
```
Каждый символ списка перечисления означает целое числ, каждое следующее число на единицу больше прошлого, а начинается с 0.

```cpp
cout << car << ' ' << train;
// выведется числа 0 и 3
```
Перечисляемые константы по умолчанию преобразуются в целочисленные, обратное преобразование автоматически не выполняется.
```cpp
how = 1; // error!
```
Используя инициализатор, можно указать значение одной или нескольких перечислимых констант. Для этого после соотвестующего элемента списка перечисления ставится знак равенства и нужное целое число. Следующему элементу списка присваивается значение, на единицу больше.
```cpp
enum transport {car, truck, airplane = 10, train, boat};
```
теперь все символы перечисления transport имеют следующие значения:

| car      | 0   |
| -------- | --- |
| truck    | 1   |
| airplane | 10  |
| train    | 11  |
| boat     | 12  |
Часто ошибочно предполагается, что символы перечисления можно вводить и выводить как строки
```cpp
// Слово train на экран таким образом не попадет
how = train;
cout << how;
```

Иногда для перевода значения перечисления в соответствующую строку можно объявить массив строк и использовать это значение в качестве индекса
```cpp
[[include]] <iostream>
using namespace std;
enum transport {car, truck, airplane, train, boat};  
char name[][20] = {  
"Automobile",  
    "Truck",  
    "Airplane",  
    "Train",  
    "Boat"  
};  
int main() {  
    transport how;  
    how = car;  
    cout << name[how] << endl;  
    how = train;  
    cout << name[how] << endl;  
    how = airplane;  
    cout << name[how] << endl;  
    return 0;  
}
```
Такой метод преобразования значения перечисления в строку можно приименить к перечислению любого типа, если оно не содержит инциализаторов. Для надлежащего индексирования массива строк перечислимые константы должны начинаться с нуля, быть строго упорядоченными по возрастанию, а каждая следующая константа должна  быть больше предыдущей точно на единицу

## Ключевое слово typedef
В языке С++ разрешается определять новые имена типов данных с помощью ключевого слова typedef. При использовании typedef - имени не создается новый тип данных, а лишь определяется новое имя для уже существующего типа.
```cpp
typedef тип имя;
```

Напиример с помощью представленного ниже оператора можно создать новое имя для типа float:
```cpp
typedef float balance;
```
Эта инструкция является предписанием компилятору распознавать идентификатор balance как еще одно имя для типа float.

С С++ лучше использовать using;
```cpp
using имя = тип;
```

## Побитовые операции
C++ разработан так, чтобы предоставить полный доступ к аппаратным средства компьютера, он дает возможность напрямую воздействовать на отдельные биты в рамках байта или машинного слова. Именно поэтому С++ содержит побитовые операции.
Они предназначены для тестирования, установки или сдвига реальных битов в байтах или словах, они соответсвуют символьным и целочисленным типам С++.

Побитовые операции не применяются для операндов:
- bool
- float
- double
- long double
- void 
- других еще более сложных типов данных

Часто используются для решения для программирования на системном уровне. Например, при запросе информации о состоянии устройства или ее получении


| Операция | Действие                                    |
| -------- | ------------------------------------------- |
| &        | Побитовая операция AND(И)                   |
| \|       | Побитовая операция OR(ИЛИ)                  |
| ^        | Побитовая операция XOR(исключающее ИЛИ)     |
| ~        | Дополнение до единицы(унарная операция NOT) |
| >>       | Сдвиг вправо                                |
| <<       | Сдвиг влево                                 |
### Побитовые операции AND,OR,XOR и NOT
Побитовые операции AND,OR,XOR,NOT действуют аналогично своим логическим эквивалентам(согласно таблице истинности). Отличие состоит лишь в том, что они работают на побитовой основе

#### XOR

| p   | q   | p^q |
| --- | --- | --- |
| 0   | 0   | 0   |
| 1   | 0   | 1   |
| 1   | 1   | 0   |
| 0   | 1   | 1   |
Результат применения операции XOR будет равен значению true(1) только в том случае, если истинен(равен 1) лишь один из операндов. В противном случае результат примет значение false(0).


#### AND 
Можно представить как способ подавления битовой информации. Это значит, что = в любом операнде обеспечит установку в 0 соответствующего бита результата
```
	1 1 0 1 0 0 1 1
&
	1 0 1 0 1 0 1 0
	- - - - - - - -
	1 0 0 0 0 0 1 0
```
Применение операции демонстрируется в представленной ниже программе. Она преобразует любой строчный символ в его прописной эквивалент путем установки шестого бита равным значению 0. Набор символов ASCII определен так, что строчные буквы имеют почти такой же код, что и прописные, за исключением того, что код первых отличается от кода вторых ровно на 32. Таким образов нам надо обнулить 6 бит.
```cpp
[[include]] <iostream>
using namespace std;
int main() {  
   char ch;  
    for ( int i = 0; i < 10; i++ ) {  
        ch = 'a' + i;  
        cout << ch; 
        // Эта операция делает Строчную букву в Прописную, обнуляет 6 бит 
        ch = ch & 223;  
        cout << ch << " ";  
    }  
    return 0; 
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 7/Lesson 7/cmake-build-debug/Lesson_7"
aA bB cC dD eE fF gG hH iI jJ 
Process finished with exit code 0
```
Значение $223_{10}$ = $1101 1111_2$ 

Операция также полезна, если нужно определить, установлен интересующий вас бит(то есть равен ли он значению 1) или нет.

```cpp
if(status & 8){
cout << "bit 4 is on"
}
```
Переведем число $8_{10}$ в $8_2$ = $1000$
т.е в числе 8 только 1 бит равен 1 и это 4 бит => компилятор выдаст результат, если status 4 бит равен 1.

#### OR
Удобно использовать для установки нужных битов равными единице. При выполнении OR в любом операнде бита, равного 1, означает, что в результате соответствующий бит также будет равен 1

```
	1 1 0 1 0 0 1 1
|
	1 0 1 0 1 0 1 0
	- - - - - - - -
	1 1 1 1 1 0 1 1
```
Теперь с помощью OR мы можем прошлый код написать в обратную сторону, т.е. теперь Прописные меняются на строчные буквы
```cpp
[[include]] <iostream>
using namespace std;
int main() {  
    char ch;  
    for (int i = 0; i < 10; i++) {  
        ch = 'A' + i;  
        cout << ch;  
        
        ch = ch | 32x;   // Эта операция делает Прописную букву строчной, добавляя в 6 бит 1
        cout << ch << " ";  
    }  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 7/Lesson 7/cmake-build-debug/Lesson_7"
Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj 
Process finished with exit code 0
```

#### XOR
Устанавливает бит результата равным единице только в том случае, если соответствующие биты операндов различаются(т.е. не равны)

```
	0 1 1 1 1 1 1 1
^
	1 0 1 1 1 0 0 1
	- - - - - - - -
	1 1 0 0 0 1 1 0
```

Если применить ее к некоторому значению х и заранее известному значению у, а затем проделать тоже самое с результатом предыдущей операции и н, то мы снова получим х.
```
R1 = X ^ Y;
R2 = R1 ^ Y; // R2 = X
```
R2 будет иметь значение Х. Таким, образом результат последовательного выполнения двух XOR с использованием одного и того же значения дает исходное значение

Зная это, можно закодировать сообщение и декодировать его
```cpp
[[include]] <iostream>
using namespace std;

int main () {  
   char msg[] = "This is a Test";  
   char key = 88;  
   cout << "Original message: " << msg << endl;  
   for (int i =0; i < strlen(msg); i++) {  
      msg[i] = msg[i] ^ key;  
   }  
   cout << "Encoded message: " << msg << endl;  
   for (int i =0; i < strlen(msg); i++) {  
      msg[i] = msg[i] ^ key;  
   }  
   cout << "Decrypted message: " << msg << endl;  
   return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 7/Lesson 7/cmake-build-debug/Lesson_7"
Original message: This is a Test
Encoded message: 01+x1+x9x=+,
Decrypted message: This is a Test

Process finished with exit code 0
```

#### NOT
Унарная операция NOT(или операция дополнения до 1) инвертирует состояние всех битов своего операнда.
т.е. в двочиной систему:
1001 0110
применив унарную операцию NOT:
0110 1001

```cpp
[[include]] <iostream>
using namespace std;

void show_binary(unsigned int u) {  
    int t;  
    for (t = 128; t > 0; t = t / 2) {  
        if (u & t) {  
            cout << "1";  
        } else {  
            cout << "0";  
        }  
    }  
    cout << endl;  
}  
  
int main() {  
    unsigned u;  
    cout << "Enter a number between 0 and 255 ";  
    cin >> u;  
    cout << "The binary representation is: ";  
    show_binary(u);  
  
    cout << "The complement of the number: ";  
    show_binary(~u);  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 7/Lesson 7/cmake-build-debug/Lesson_7"
Enter a number between 0 and 255 99
The binary representation is: 01100011
The complement of the number: 10011100

Process finished with exit code 0

```

Операции &,|,^ и ~ применяются непосредственно к каждому биту значения в отдельности. Поэтому побитовые операции нельзя использовать вместо их логических эквивалентов в условных выражениях.

## Операции сдвига
Операция сдвига, >> и <<, сдвигают биты в значении переменной вправо или влево
```cpp
>> - вправо
<< - влево
переменная >> число_битов
переменная << число_битов
```
Число битов указывает, на сколько позиций требуется сдвинуть значение переменной.При каждом сдвиге влево все биты, составляющие значение, сдвигаются влево на одну позицию, а в младший бит записывается нуль. При сдвиге вправо все биты сдвигаются вправо, а в старший записывается нуль. Если отрицательное значение, то при каждом сдвиге вправо в старший бит записывается единица, что сохраняет знаковый бит.
Сдвиг выполняемый этими операциями не является циклическим, т.е. при сдвиге крайние биты теряются.

Операции сдвига работают только со значениями  целочисленных типов:
- int
- char
- long int
- short int
Такие операции полезны для декодирования информации, входящей от внешних устройств.
```cpp
[[include]] <iostream>
using namespace std;
void show_binary(unsigned int u) {  
    int t;  
    for (t = 128; t > 0; t = t / 2) {  
        if (u & t) {  
            cout << "1";  
        } else {  
            cout << "0";  
        }  
    }  
}  
int main() {  
    // int t = 1;  
    int i;  
    for (i = 0; i < 8; i++) {  
       int  t = 1 << i;  
        show_binary(t);  
        cout << endl;  
    }  
  
  
    for (i = 0; i < 8; i++) {  
        int t = 128 >> i;  
        show_binary(t);  
        cout << endl;  
    }  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 7/Lesson 7/cmake-build-debug/Lesson_7"
00000001
00000010
00000100
00001000
00010000
00100000
01000000
10000000
10000000
01000000
00100000
00010000
00001000
00000100
00000010
00000001

Process finished with exit code 0
```


## Операция ?
Данная операция заменяет if-else
Операция ? называется тернарной, поскольку работает с 3 операндами
Синтаксис:
```cpp
Выражение1 ? Выражение2 : Выражение3
```
Значение выражения ? определяется так.
Сначала вычисляется Выражение1. Если оно оказывается истинным, вычисляется Выражение2б и результат становится значением всего выражения ?. Если результат вычисления Выражения1 оказывается ложным, значением всего выражения ? становится результат вычисления Выражения3.

```cpp
[[include]] <iostream>
using namespace std;
int div_zero() {  
    cout << "Can't to divisor 0: ";  
    return 0;  
}  
  
int main() {  
    int i;  
    int j;  
    int result;  
  
    cout << "Enter i number: ";  
    cin >> i;  
    cout << "Enter j number: ";  
    cin >> j;  
  
    result = j ? i/j : div_zero();  
    cout << "Result is: " << result << endl;  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 7/Lesson 7/cmake-build-debug/Lesson_7"
Enter i number: 12
Enter j number: 0
Can't to divisor 0: Result is: 0

Process finished with exit code 0

```
## Операция ,
Ее назначение связать несколько выражений.
Значение списка выражений, разделенных запятыми, определяется в этом случае значением крайнего справа выражения. Значение других выражений отбрасывается. Таким образом, значение выражения справа становится значениме всего выражения-списка
```cpp
var = (count = 19, incr = 10, count + 1);
```
count вначале присваивается число 19, переменной incr число 10, а затем к значению переменной count прибавляется единица, после чего переменной var присваивается значение крайнего справа выражения, т.е. 20.

```cpp
[[include]] <iostream>
using namespace std;
int main() {  
    int i;  
    int j;  
    j = 10;  
    i = (j++, j + 100, 999 + j);  // Изначально у нас j = 10, потом с помощью j++ к j добавляется 11 и j = 11, затем к j прибавляется 100 и j = 111 и в конце добавляется 999 к j и i равен 1010
    cout << i << endl;  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 7/Lesson 7/cmake-build-debug/Lesson_7"
1010

Process finished with exit code 0
```

Значение операции , - обеспечить выполнение заданной последовательности операций. Операцию можно сравнить с союзом и, т.е. сделай это, и то и другое...

### Множественные присваивания
Язык С++ позволяет примень удобный метод одновременного присваивания многим переменным одного и того же значение:
```cpp
count = index = incr = 10;
```

## Составные операции присваивания
В языке С++ предусмотрены специальные составные операции, в которых присваивание объединено еще с одной переменной
Например:
```cpp
x = x + 10;
// Можно записать
x += 10;
```
## Использование ключевого слова sizeof
Поскольку размеры встроенных в С++ типов данных в разных вычислительных средах могут отличаться, невозможно заранее узнать размер перуменной для каждого случая. Чтобы решить эту проблема, в С++ включена операция sizeof, которая используется в двух следующих синтаксисах:
```cpp
sizeof (тип);
sizeof переменная;
```
Первая версия возвращает размер заданного типа данных, а вторая - размер заданной переменной.

```cpp
[[include]] <iostream>
using namespace std;
int main() {  
    char ch;  
    int i;  
    int nums[4];  
    cout << sizeof nums << ' ';  
    cout << sizeof ch << ' ';  
    cout << sizeof i << ' ';  
    cout << sizeof(float) << ' ';  
    cout << sizeof(double) << ' ';  
    return 0;  
}
```
```
"/Users/phil/Git/C++Beginer/Lesson 7/Lesson 7/cmake-build-debug/Lesson_7"
16 1 4 4 8 
Process finished with exit code 0
```
Операцию sizeof можно применить к любому типу данных. Например, в случае применения к массиву она возвращает количество занимаемых им байтов.
Для 4-х байтных значений типа int при выполнении отобразится число 16.




