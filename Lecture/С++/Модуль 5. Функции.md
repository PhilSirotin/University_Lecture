Функция - подпрограмма, которая содержит один или несколько операторов и выполняет определенную задачу.

## Синтаксис функций в С++
Все функции в С++ имеют следующий вид:
```cpp
тип_возвращаемого_значения имя_функции(список_параметров)
{
 //Тело функции
}
```
С помощью типа_возвращаемого_значения указывается тип значения, возвращаемого функцией. Это может быть практически любой тип, за исключением массива. Если функция не возвращает никакого значения, необходимо указать тип void. Если функция действительно возвращает значение, оно должно иметь тип, совместимый с указанным в определении функции.

В качестве имени можно использовать любое имя, которое не было еще задействовано

После имени функции в круглых скобках указывается список_параметров, который представляет собой последовательность пар, разделенных запятыми.
Параметры - переменные ,которые получают значение аргументов, передаваемых функции при вызове. Если функция не имеет параметров, то список_параметров отсутствует, то есть круглые скобки остаются пустыми.


## Создание функций
```cpp
[[include]] <iostream>  
  
using namespace std;  
  
void New_Function();  
  
int main () {  
    cout << "Inside main()" << endl;  
    New_Function();  
    cout << "This is main function" << endl;  
    return 0;  
}  
  
void New_Function()  
{  
    cout << "Inside New_Function()" << endl;  
}```

Для использований функций компилятору нужно показать их до вызова функции int main(){}

## Аргументы функции
Функции можно передать одно или несколько значений
Аргумент - значение, передаваемое функции
Параметры функции - объявляемые переменные, которые получают значения этих аргументов

## Возвращение значений функций
Инструкция *return* имеет две формы. 
1-я позваляет возвращать значение, а 2-я нет.
2-я:
если типо возвращаемойго значения определяется ключевым словом *void* , то для выхода из функции достаточно использовать такую форму интсрукции return:
```cpp
return;
```
## Возврат значений
Функция может возвращать значение инициатору своего языка. Таким, образом, возвращаемое функцией значение - средство получения информации из нее. Чтобы вернуть значение, используйте вторую форму инструкции return;
```cpp
return значение;
```
Эту форму return можно применять только с теми функциями, которые возвращают значение, отличное от void.

## Локальная область видимости
Создается блоком(начинается с открывающей фигурной скобки и завершается закрывающей)
Переменная объявленная внутри любого блока кода называется локальной(по отношению к этому блоку)
Локальную переменную могут использовать лишь операторы, включенные в блок, в котором эта переменная объявлена
## Глобальная область видимости
Глобальная область видимости - декларативная область, которая заполняет пространство вне всех функций.
При объявлении переменной в глобальной области видимости создается глобальная переменная
Глобальные переменные известны на протяжении всей программы, их можно использовать в любом месте, и они поддерживают свои значения во время выполнения всего кода
Без особой необходимости лучше избегать глобальный переменных причины:
1. Они занимают память в течение всего времени выполнения программы, а не только тогда, когда действительно нужны
2. Использование глобальной переменной для решения задачи, с которой легко бы справилась локальная, делает функцию менее универсальной, ведь зависит от данных, определенных за ее пределами
3. Большое количество глобальных переменных может привести к появлению ошибок в работе программы по причине неизвестных и нежелательных побочных эффектов. Основная проблема, характерная для разработки больших программ на С++ - случайная модификация значения переменной в каком то другом месте кода. Чем больше глобальных переменных в программе, тем выше вероятность ошибки

## Передача указателей и массивов функции
### Передача указателя
Чтобы передать указатель в качестве аргумента функции, необходимо объявить параметр типа указатель
```cpp
[[include]] <iostream>

using namespace std;

void fun(int *j);  
  
int main() {  
    int i;  
    int *p;  
    p = &i;  
    fun(p);  
    cout << i << endl;  
    return 0;  
}  
  
void fun(int *j) {  
    *j = 100;  
}
```

### Передача массива
Если аргументов функции является массив, то при ее вызове ей передается только адрес первого элемента массива, а не полная его копия. Это означает, что объявление должно иметь тип, совместимый с типом аргумента. Есть три способа объявления параметра, который принимает указатель на массив. 
Например, его можно объявить как массив, используемого при вызове функции

```cpp
[[include]] <iostream>

using namespace std;

void display(int num[10]);  
  
int main() {  
    int t[10];  
    int i;  
  
    for (i = 0; i < 10; i++) {  
        t[i] = i;  
    }  
    display(t);  
    return 0;  
}  
  
void display(int num[10]) {  
    for (int i = 0; i < 10; i++) {  
        cout << num[i] << " ";  
    }  
}
```

Второй способ:
состоит в его представлении в виде безразмерного массива
```cpp
[[include]] <iostream>

using namespace std;

void display(int num[]);  
  
int main() {  
    int t[10];  
    int i;  
  
    for (i = 0; i < 10; i++) {  
        t[i] = i;  
    }  
    display(t);  
    return 0;  
}  
  
void display(int num[]) {  
    for (int i = 0; i < 10; i++) {  
        cout << num[i] << " ";  
    }  
}

```

Третий способ:
При передаче массива функции ее параметр можно объявить как указатель
```cpp
[[include]] <iostream>
using namespace std;
void display(int *num);  
  
int main() {  
    int t[10];  
    for (int i = 0; i < 10; i++) {  
        t[i] = i;  
    }  
  
    display(t);  
    return 0;  
}  
  
void display(int *num) {  
    // int i;  
    for (int i = 0; i < 10; i++) {  
        cout << num[i] << " " << endl;  
    }  
}
```

### Передача строк
Поскольку строки в С++ - обычные символьные массивы, которые завершаются нуль-символом, при передаче функции строки реально передается только указатель (типа char) на начало этой строки
```cpp
[[include]] <iostream>
using namespace std;
void StInvert(char *str);  
  
int main() {  
    char str[80];  
  
    cout << "Enter a string: ";  
    cin.getline(str, 80);  
    StInvert(str);  
    cout << str << endl;  
    return 0;  
}  
  
void StInvert(char *str) {  
    while (*str) {  
        if (isupper(*str)) {  
            *str = tolower(*str);  
  
        } else if (islower(*str)) {  
            *str = toupper(*str);  
  
        }  
        str++;  
    }  
  
}
```
## Возвращение указателей
Функции могут возвращать указатели, так же как и значения любых других типов данных, и при этом особых проблем не возникает.
Чтобы вернуть указатель, функция должна объявить его тип в качестве типа возвращаемого значения. Приведем пример возвращаемого значения для функции f(), которая должна возвращать указатель на целое число
```cpp
int *f();
```
Если функция возвращает указатель, то значение, используемое в ее инструкции 
```cpp
return
```
также должно быть указателем.

```cpp
[[include]] <iostream>
using namespace std;
char *get_substr(char *sub, char *str);  
  
int main() {  
    char *substr;  
    substr = get_substr("three", "one two three four");  
    cout << "Substring found: " << substr << endl;  
    return 0;  
}  
  
char *get_substr(char *sub, char *str) {  
    int t;  
    char *p;  
    char *p2;  
    char *start;  
    for (t = 0; str[t]; t++) {  
        p = &str[t];  
        start = p;  
        p2 = sub;  
        while (*p2 && *p2 == *p) {  
            p++;  
            p2++;  
        }  
        if (!*p2) {  
            return start;  
        }  
    }  
    return 0;  
}
```
### Функция main
Main - особенная, поскольку это первая функция вызываемая при выполнении программы. В отличие от некоторых других языков, в которых выполнение всегда начинается сверху, то есть с первой строки кода, каждая программа на С++ стартует с вызова main() вне зависимости от ее расположения.

## Передача аргументов командной строки функции main()
Это реализуется путем передачи аргументов командной строки функции main(). Такой аргумент представляет собой информацию, которая указывается после имени программы в командной строке ОС. 

Например, программы на С++ можно компилировать путем выполнения следующей команды 
`c1 им_программы`
Здесь указывается имя_программы, которую мы хотим скомпилировать. Оно передается компилятору С++ в качестве аргумента командной строки.

В языке С++ для функции main() определено два встроенных, но не обязательных параметра argc and argv, которые получают свои значения от аргументов командной строки. 

Параметр argc имеет целочисленный тип и предназначен для хранения количества аргументов командной строки. Его значение всегда не меньше единицы, потому что имя программы считается первым аргументом

Параметр argv представляет собой указатель на массив символьных указателей. Каждый указатель в массиве argv ссылается на строку, которая содержит аргумент командной строки.

Объявление параметра argv
```cpp
char *argv []
```
Доступ к отдельным аргументам командной строки можно получить путем индексации массива argv.

Как правило, аргументы argc and argv используются ждя ввода в программу начальных параметром, исходных значений, имен файлов или вариантов(режимов) работы программы

```cpp
[[include]] <iostream>
using namespace std;

int main(int argc, char *argv[]) {  
    for (int i = 1; i < argc; i++) {  
        cout << argv[i] << endl;  
    }  
    return 0;  
}
```

### Передача числовых аргументов командной строки
При передаче программе числовых данных в качестве аргументов командной строки эти данные принимаются в строковой форме. Необходимо предусмотреть их преобразование в подходящий внутренний формат с помощью одной из стандартных библиотечных функций.

```cpp
atof()"- Преобразует строку в значение типа double и возвращает результат"
atol()"- Преобразует строку в значение типа long int и возвращает результат"
atoi()"- Преобразует строку в значение типа int и возвращает результат"
```
Каждая из этих функций использует при вызове в качестве аргумента строку, содержащую числовое значение. Для их вызова необходимо включить в программу заголовочный файл  cstdlib.
```cpp
[[include]] <iostrem>
using namespace std;

int main(int argc, char *argv[]) {  
    double a;  
    double b;  
  
    if (argc != 3) {  
        cout << "Usage: add num num:)";  
        return 1;  
    }  
    a = atof(argv[1]);  
    b = atof(argv[2]);  
  
    cout << a + b << endl;  
  
    return 0;  
}
```

## Прототипы функций
В С++ все функции должны быть объявлены до использования. Обычно это реализуется с помощью прототипа.
Прототипы содержат три вида информации о функции:
- тип возвращаемого ею значения
- тип ее параметров
- количество параметров

Прототипы позволяют компилятору выполнить следующие три важные операции:
- Они сообщают компилятору, код какого типа требуется генерировать при вызове функции. Различия в типах параметров и значении, возвращаемом функцией, обеспечивают разную обработку компилятором
- Находить недопустимые преобразования между типами аргументов, используемых пи вызове функции, и типами, указанными в объявлении ее параметров, и сообщать о них
- Они позволяют компилятору выявить различия между количество аргументов, которые используются при вызове функции, и количество параметров, заданных в ее определении
Общая форма прототипа функции:
```cpp
тип имя_функции(тип имя_функции1, тип имя_параметра2, ... , тип имя_параметраN);
```

## Рекурсивные функции
