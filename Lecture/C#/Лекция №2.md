## Основы C#

В языке С# каждый тип может быть отнесен к одной из категорий: class,struct,enum,interface, delegate.

Литералы

**Это непосредственно значения переменных**

- double y = 3.14;
- string hello = "Hello Invader!";
- char c = 's';
- int x = 0b11;
- int r = 0b0011_1101;
- int x = 0xFF0D;
- Console.WriteLine(4.5e2);
- Console.WriteLine(3.2e-3);
- Console.WriteLine(‘ \x78 ’);
- Console.WriteLine(‘ \u0420 ’);

## Литералы

_Литеральная строка -_ символы, заключенные в двойные кавычки. Они могут использовать escape - символы, такие как \t для табуляции. Чтобы вывести обратные слеш, используйте два символа \\.

_Дословная литеральная строка -_ литеральная строка с префиксом @ для отключения управляющих символов. Вдобавок позволяет строковому значению занимать несколько строк, поскольку пробелы рассматриваются как отдельные символы, а не как инструкции для компилятора.

_Интерполированная строка - литеральная строка с префиксом $ для включения встроенных форматированных переменных._

## Числа

- Операция sizeof(), возвращает количество байтов, используемых в памяти данным типом
- **MaxValue**, возвращающие минимальные и максимальные значения, которые могут храниться в переменной этого типа.

## Сравнение типов double и decimal

double a = 0.1;

double b = 0.2;

if(a + b == 0.3)

{

Console.WriteLine($”{a} + {b} equals {0.3}”);

}

else

{

Console.WriteLine($”{a} + {b} does Not equal {0.3}”);

}

Тип **object**

- object height = 1.88;
- object name = “Amir”;
- Console.WriteLine($”{name} is {height} metres tall.”);
- int length1 = name.length; // выдаст ошибку компиляции
- int length2 = ((string)name).length;
- Console.WriteLine($”{name} has {length2} characters. “);

## Правила вывода типа переменной

- Числовой литерал без десятичной запятой определяется как переменная int, если не добавлен следующий суффикс:
- L означает long;
- UL означает ulong;
- M означает decimal;
- D означает double;
- F означает float;
- Числовой литерал с десятичной запятой определяется как double. Если добавить суффикс M, то определяется как переменная decimal; если F - то как переменная float.
- Двойные кавычки обозначают переменную string, а одинарные - переменную char. Значения true и false определяют тип bool.

## Преобразование типов и переполнение

double d = 143.324;

int c = d; // неявное приведение типов

int c = int(d) // явное

String st = “1”;

i = (int)st; // ошибка

i = int.Parse(st)

int a = 100;

int b = 224;

byte c = checked((byte)(a + b));

Console.WriteLine(c);

## Преобразование типов

- Метод **Parse()** в качестве параметра принимает строку и возвращает объект текущего типа

int a = int.Parse(”10”);

double b = double.Parse(”23.56”);

decimal c = decimal.Parse(”12.45”);

byte d = byte.Parse(”4”);

Console.WriteLine($”a = {a} b = {b} c = {c} d = {d}”);

- Метод **TryParse()** преобразует строку к типу и, если преобразование прошло успешно, то возвращает **true.**

Ключевое слово **out** требует для того, чтобы разрешить методу TryParse устанавливать переменную number при проведении пробразований

## Оператор проверки null(??)

int? x = null;

int y = x?? -1;

- Оператор ?? называется - Null-coalescing operator. Если значение переменной равно Null, то возвращается значение стоящее справа от оператора.
- В данном примере переменной у присваивается значение -1.
- Можно достичь того же с помощью оператора if.

## StringBuilder

- В отличие от методов класса String, StringBuilder работает с самими экземплярами объектов, т.е. изменяет переменные.
- Этот тип работает быстрее чем все ранее описанное
- StringBuilder st = new StringBuilder();
- st.Append(”My”);
- Console.WriteLine(st.ToString());

## Когда надо использовать класс String, а когда StringBuilder?

**Рекомендовано использовать String в следующих случаях:**

---

- При небольшом количестве операций и изменений над строками
- При выполнении фиксированного количества операций объединения. В этом случае компилятор может объединить все операции объединения в одну
- Когда надо выполнять масштабные операции поиска при построении строки, например IndexOf или StartsWith. Класс StingBuilder не имеет подобных методов.

Класс StringBuilder рекомендуется использовать в следующих случаях:

- При неизвестном количестве операций и изменений над строками во время выполнения программы
- Когда предполагается, что приложению придется сделать множество подобных операций

## Метод Массива

**Clear(Array, Int32, Int32)** : этот метод используется для установки диапазона элементов по умолчанию в зависимости от типа элемента.

**Clone ():** этот метод используется для создания копии элемента.

**CopyTo(Array, Array, Int32):** этот метод используется для копирования элементов одного массива в другой.

**Equals (Object):** этот метод в основном проверяет, равен ли упомянутый объект текущему объекту.

**Sort (Array):** этот метод используется для сортировки массива.

**CreateInstance (Type, Int32):** этот метод используется для создания массива определенного типа, длины и размера.

**ToString ():** используется для отображения строкового представления.

**GetType ():** этот метод используется для возврата типа объекта.

**IndexOf (Array, Object):** этот метод используется для поиска конкретного объекта и возврата индекса первого вхождения в одномерном массиве.

**Reverse (Array):** этот метод используется для изменения последовательности элементов.

**SetValue (Object, Int32):** этот метод в массиве 1D используется для установки значения элемента.

## Массив и коллекции

- Массив это коллекция с заранее заданным числом элементов
- Int[] a1=new int[5];
- Int[] a2 = new int[5] {1,2,3,4,5}
- Int[] a3= {1,2,3,4,5};
- Array a4 = new int[5];
- Array a5 = Array.CreateInstance (typeof(int),5);
- A5.SetValue (12,0);

## Класс Array

- int[] num = {1,2,3,4,5,6,7,8,9};
- int index -= Array.BinarySearch (num, 7);
- int[] num2 = new int[10];
- Array.Copy (num, num2, num.Length);
- int[] num3 = new int[10];
- num2.CopyTo (num3, 0); // копирование на уровне экземпляра
- Array.Sort(num );
- Array.Copy(num , num 2, num.Length);